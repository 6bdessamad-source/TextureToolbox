<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture Toolbox Pro V10</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            /* --- BASICS --- */
            --bg-body: #050505;
            --bg-card: #121212;
            --bg-input: #1a1a1a;
            --bg-hover: #252525;
            --bg-elevated: #1e1e1e;
            
            --border: #2a2a2a;
            --border-active: #404040;
            
            --text-main: #ffffff;
            --text-sec: #9ca3af;
            --text-dim: #6b7280;
            
            /* --- MODES COLORS --- */
            --col-create: #d17756;   /* Terracotta */
            --col-convert: #c026d3;  /* Magenta */
            --col-separate: #0ea5e9; /* Sky Blue */
            --col-editor: #10b981;   /* Emerald */
            --col-channels: #f59e0b; /* Amber */

            /* Default Accent (Will change via JS) */
            --accent: var(--col-create);
            --accent-dim: rgba(209, 119, 86, 0.15);
            
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            
            --shadow: 0 8px 30px rgba(0,0,0,0.5);
            --radius: 12px;
            --font-ui: 'Inter', sans-serif;
            --nav-height: 70px;
            
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        [data-theme="light"] {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-input: #f1f5f9;
            --bg-hover: #e2e8f0;
            --bg-elevated: #ffffff;
            --border: #e2e8f0;
            --border-active: #cbd5e1;
            --text-main: #0f172a;
            --text-sec: #64748b;
            --text-dim: #94a3b8;
            --shadow: 0 10px 30px rgba(0,0,0,0.08);
            --grid-color: rgba(0, 0, 0, 0.03);
        }

        * { box-sizing: border-box; outline: none; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg-body);
            /* Dot Grid Background */
            background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: 24px 24px;
            color: var(--text-main);
            font-family: var(--font-ui);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        /* --- HEADER --- */
        .navbar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0 1.5rem;
            height: var(--nav-height);
            display: flex; align-items: center; justify-content: space-between;
            flex-shrink: 0; z-index: 100;
        }

        .brand {
            display: flex; align-items: center; gap: 12px;
            font-weight: 800; font-size: 1.1rem; letter-spacing: -0.5px;
        }
        .brand-icon {
            width: 36px; height: 36px; background: var(--bg-input);
            border: 1px solid var(--border); border-radius: 8px;
            overflow: hidden; display: flex; align-items: center; justify-content: center;
        }
        .brand-icon img { width: 100%; height: 100%; object-fit: contain; }
        .brand-text span { color: var(--accent); transition: color 0.3s; }

        .nav-center {
            display: flex; gap: 4px; background: var(--bg-input);
            padding: 4px; border-radius: 8px; border: 1px solid var(--border);
            overflow-x: auto; max-width: 60vw;
        }
        .nav-tab {
            padding: 6px 16px; border: none; background: transparent;
            color: var(--text-sec); font-weight: 600; cursor: pointer;
            border-radius: 6px; font-size: 0.8rem; white-space: nowrap;
            transition: all 0.2s;
        }
        .nav-tab:hover { color: var(--text-main); background: var(--bg-hover); }
        .nav-tab.active { background: var(--bg-card); color: var(--accent); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        .nav-right { display: flex; gap: 10px; }
        .icon-btn {
            width: 36px; height: 36px; border-radius: 8px;
            background: var(--bg-input); border: 1px solid var(--border);
            color: var(--text-sec); cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.1rem; transition: all 0.2s;
        }
        .icon-btn:hover { border-color: var(--accent); color: var(--accent); }

        /* --- MAIN LAYOUT --- */
        .main-container {
            display: grid; grid-template-columns: 400px 1fr; gap: 24px;
            padding: 24px; flex: 1; max-width: 1800px; margin: 0 auto;
            width: 100%; overflow: hidden;
        }

        .panel {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); display: flex; flex-direction: column;
            overflow: hidden; box-shadow: var(--shadow); position: relative;
        }

        .panel-header {
            padding: 16px 20px; border-bottom: 1px solid var(--border);
            font-weight: 700; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--bg-elevated); color: var(--text-sec);
        }
        .panel-badge {
            font-size: 0.65rem; background: var(--accent-dim); padding: 2px 8px;
            border-radius: 4px; color: var(--accent); border: 1px solid var(--accent);
        }

        .panel-scroll { padding: 20px; overflow-y: auto; flex: 1; }

        /* --- CONTROLS --- */
        .config-group { margin-bottom: 20px; }
        label {
            display: block; font-size: 0.75rem; font-weight: 700;
            color: var(--text-dim); margin-bottom: 8px; text-transform: uppercase;
        }
        select {
            width: 100%; padding: 12px; background: var(--bg-input);
            border: 1px solid var(--border); color: var(--text-main);
            border-radius: 8px; cursor: pointer; font-size: 0.9rem; appearance: none;
        }
        select:focus { border-color: var(--accent); }

        /* --- SLOTS & UPLOADS --- */
        .slots-wrapper { display: flex; flex-direction: column; gap: 10px; }
        
        .slot {
            position: relative; background: var(--bg-input);
            border: 1px solid var(--border); border-radius: 8px; padding: 10px;
            display: flex; align-items: center; gap: 12px; transition: all 0.2s;
        }
        .slot:hover { border-color: var(--border-active); background: var(--bg-hover); }
        .slot.filled { background: var(--bg-card); border-left: 4px solid var(--success); }
        .slot.missing { border-left: 4px dashed var(--warning); opacity: 0.9; }

        .ch-badge {
            width: 32px; height: 32px; border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 800; font-size: 0.8rem; color: #fff; flex-shrink: 0;
        }
        .bg-R { background: #ef4444; } .bg-G { background: #10b981; }
        .bg-B { background: #3b82f6; } .bg-A { background: #6b7280; }
        .bg-M { background: #c026d3; } /* Magenta for Mix */

        .slot-info { flex: 1; pointer-events: none; min-width: 0; }
        .slot-name { font-weight: 600; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-main); }
        .slot-meta { font-size: 0.7rem; color: var(--text-dim); display: flex; gap: 6px; align-items: center; }
        
        /* Indicators */
        .tag { font-size: 0.6rem; font-weight: 700; padding: 1px 4px; border-radius: 3px; }
        .tag-edit { color: var(--warning); background: rgba(245, 158, 11, 0.1); border: 1px solid var(--warning); }

        /* Upload Overlay */
        .file-input { position: absolute; inset: 0; opacity: 0; cursor: pointer; z-index: 1; }
        .import-visual {
            position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
            display: flex; align-items: center; gap: 6px; pointer-events: none;
            color: var(--text-dim); font-size: 0.75rem; font-weight: 600;
        }
        .slot:hover .import-visual { color: var(--accent); }
        .slot.filled .import-visual { display: none; }

        /* Actions */
        .slot-actions { display: flex; gap: 4px; z-index: 2; }
        .mini-btn {
            width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
            background: var(--bg-input); color: var(--text-sec); cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        .mini-btn:hover { color: var(--accent); border-color: var(--accent); background: var(--bg-elevated); }

        /* --- PREVIEW --- */
        .preview-wrapper {
            flex: 1; display: flex; flex-direction: column; background-color: var(--bg-input);
            background-image: 
                linear-gradient(45deg, var(--border) 25%, transparent 25%), 
                linear-gradient(-45deg, var(--border) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, var(--border) 75%), 
                linear-gradient(-45deg, transparent 75%, var(--border) 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            align-items: center; justify-content: center; padding: 20px; overflow: hidden;
        }
        canvas { max-width: 100%; max-height: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 8px; object-fit: contain; }

        .empty-state { text-align: center; color: var(--text-dim); opacity: 0.5; }
        .empty-icon { font-size: 3rem; margin-bottom: 10px; }

        /* --- RESULTS GRID --- */
        .results-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px; width: 100%; padding: 15px; background: var(--bg-elevated);
            border-top: 1px solid var(--border); max-height: 250px; overflow-y: auto;
        }
        .result-card {
            background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px;
            padding: 8px; display: flex; flex-direction: column; gap: 8px;
        }
        .result-thumb {
            aspect-ratio: 1; background: #000; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .result-thumb canvas { width: 100%; height: 100%; box-shadow: none; border: none; }
        .dl-btn {
            width: 100%; padding: 6px; background: var(--bg-input); border: 1px solid var(--border);
            border-radius: 4px; color: var(--text-main); font-size: 0.7rem; cursor: pointer;
            text-align: center; text-decoration: none; font-weight: 600;
        }
        .dl-btn:hover { background: var(--accent); border-color: var(--accent); color: #fff; }

        /* --- EDITOR CONTROLS (SIDEBAR) --- */
        .editor-controls { display: none; margin-top: 20px; }
        .slider-row { margin-bottom: 12px; }
        .slider-head { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-sec); margin-bottom: 4px; }
        input[type=range] { width: 100%; -webkit-appearance: none; background: var(--bg-input); height: 4px; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer;
        }

        /* --- MAIN ACTION --- */
        .action-area { padding: 20px; background: var(--bg-elevated); border-top: 1px solid var(--border); }
        .btn-large {
            width: 100%; padding: 14px; border: none; border-radius: 10px;
            background: var(--accent); color: #fff; font-weight: 700; font-size: 0.95rem;
            cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.2); transition: all 0.2s;
        }
        .btn-large:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-1px); }
        .btn-large:disabled { opacity: 0.5; cursor: not-allowed; background: var(--bg-input); color: var(--text-sec); box-shadow: none; transform: none; }

        /* --- FOOTER --- */
        .footer {
            background: var(--bg-card); border-top: 1px solid var(--border); padding: 15px 24px;
            display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: var(--text-sec);
        }
        .author { color: var(--accent); font-weight: 700; text-decoration: none; }
        .social-link { text-decoration: none; color: inherit; display: flex; align-items: center; gap: 6px; transition: color 0.2s; }
        .social-link:hover { color: var(--text-main); }
        .social-link svg { width: 16px; height: 16px; fill: currentColor; }

        .d-none { display: none !important; }
        
        /* Modal for specific edits */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 999; display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
        .modal-overlay.active { display: flex; }
        .modal-box { background: var(--bg-card); width: 400px; padding: 20px; border-radius: 12px; border: 1px solid var(--border); }

        @media (max-width: 900px) {
            .main-container { grid-template-columns: 1fr; padding: 10px; height: auto; overflow: visible;}
            .panel { height: auto; min-height: 400px; }
            .nav-tabs { display: none; /* Hide on mobile, maybe add burger later */ }
        }
    </style>
</head>
<body>

    <nav class="navbar">
        <div class="brand">
            <div class="brand-icon">
                <img src="logo.png" alt="TP" onerror="this.style.display='none'">
            </div>
            <div class="brand-text">Texture<span>Toolbox</span></div>
        </div>
        
        <div class="nav-center">
            <button class="nav-tab active" onclick="setMode('create')">Create</button>
            <button class="nav-tab" onclick="setMode('convert')">Convert</button>
            <button class="nav-tab" onclick="setMode('separate')">Separate</button>
            <button class="nav-tab" onclick="setMode('editor')">Editor</button>
            <button class="nav-tab" onclick="setMode('channels')">Channels</button>
        </div>

        <div class="nav-right">
            <button class="icon-btn" onclick="toggleTheme()">â˜€</button>
        </div>
    </nav>

    <div class="main-container">
        
        <div class="panel">
            <div class="panel-header">
                <span id="panelTitle">Configuration</span>
                <span class="panel-badge" id="modeBadge">CREATE</span>
            </div>
            <div class="panel-scroll">
                
                <div id="sourceConfig" class="d-none config-group">
                    <label>Source File</label>
                    <div class="slot missing" id="sourceSlot">
                        <div class="ch-badge bg-M">SRC</div>
                        <div class="slot-info">
                            <div class="slot-name" id="sourceName">Select Image</div>
                            <div class="slot-meta">Drag & Drop or Click</div>
                        </div>
                        <input type="file" class="file-input" id="sourceInput" accept="image/*">
                    </div>
                    
                    <div id="srcFormatGroup" style="margin-top:12px;">
                        <label>Source Format</label>
                        <select id="sourceFormat"></select>
                    </div>
                </div>

                <div id="channelsConfig" class="d-none config-group">
                    <label>Operation</label>
                    <select id="channelOp" onchange="updateUI()">
                        <option value="merge">Merge Channels (Builder)</option>
                        <option value="split">Split Channels (Extractor)</option>
                    </select>
                </div>

                <div id="targetConfig" class="config-group">
                    <label>Output Preset</label>
                    <select id="targetFormat"></select>
                </div>

                <div id="editorControls" class="editor-controls">
                    <div class="slider-row"><div class="slider-head"><span>Brightness</span><span id="v-b">100%</span></div><input type="range" id="sl-b" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Contrast</span><span id="v-c">100%</span></div><input type="range" id="sl-c" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Saturation</span><span id="v-s">100%</span></div><input type="range" id="sl-s" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Hue</span><span id="v-h">0Â°</span></div><input type="range" id="sl-h" min="-180" max="180" value="0"></div>
                    <div class="slider-row"><div class="slider-head"><span>Sharpness</span><span id="v-sh">0</span></div><input type="range" id="sl-sh" min="0" max="10" step="1" value="0"></div>
                    <div class="slider-row"><div class="slider-head"><span>Threshold</span><span id="v-th">0</span></div><input type="range" id="sl-th" min="0" max="255" value="0"></div>
                    <button class="mini-btn" style="width:100%; margin-top:10px;" onclick="applyRealtimeEdit()">Apply & Render</button>
                </div>

                <div id="slotsSection" style="margin-top:20px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                        <label id="slotTitle">Channels</label>
                    </div>
                    <div class="slots-wrapper" id="slotsArea"></div>
                </div>

            </div>
            <div class="action-area">
                <div class="config-group" style="margin-bottom:10px;">
                    <label>Export As</label>
                    <select id="exportType" style="padding:8px;">
                        <option value="png">PNG (Lossless)</option>
                        <option value="jpg">JPG (Compact)</option>
                        <option value="webp">WebP (Modern)</option>
                    </select>
                </div>
                <button id="processBtn" class="btn-large" disabled>Process</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <span>Viewport</span>
                <span id="dimInfo" style="color:var(--text-dim); font-weight:400;">0 Ã— 0</span>
            </div>
            
            <div class="preview-wrapper" id="previewContainer">
                <div class="empty-state">
                    <div class="empty-icon">ðŸ–¼</div>
                    <div>Preview Output</div>
                </div>
            </div>
            
            <div id="resultsGrid" class="results-grid" style="display:none;"></div>
        </div>

    </div>

    <footer class="footer">
        <div>Designed by <span class="author">Abdessamad SAFHA</span></div>
        <div style="display:flex; gap:20px;">
            <a href="mailto:6bdessamad@gmail.com" class="social-link">
                <svg viewBox="0 0 24 24"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
                Email
            </a>
            <a href="https://www.instagram.com/2bdessamad/" target="_blank" class="social-link">
                <svg viewBox="0 0 24 24"><path d="M7.8,2H16.2C19.4,2 22,4.6 22,7.8V16.2A5.8,5.8 0 0,1 16.2,22H7.8C4.6,22 2,19.4 2,16.2V7.8A5.8,5.8 0 0,1 7.8,2M7.6,4A3.6,3.6 0 0,0 4,7.6V16.4C4,18.39 5.61,20 7.6,20H16.4A3.6,3.6 0 0,0 20,16.4V7.6C20,5.61 18.39,4 16.4,4H7.6M17.25,5.5A1.25,1.25 0 0,1 18.5,6.75A1.25,1.25 0 0,1 17.25,8A1.25,1.25 0 0,1 16,6.75A1.25,1.25 0 0,1 17.25,5.5M12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9Z"/></svg>
                Instagram
            </a>
        </div>
    </footer>

    <script>
        // --- CONFIG ---
        const MODES = {
            create: { col: '--col-create', name: 'Create', badge: 'PACKER' },
            convert: { col: '--col-convert', name: 'Convert', badge: 'UNPACKER' },
            separate: { col: '--col-separate', name: 'Separate', badge: 'SPLITTER' },
            editor: { col: '--col-editor', name: 'Editor', badge: 'STUDIO' },
            channels: { col: '--col-channels', name: 'Channels', badge: 'MIXER' }
        };

        const FORMATS = {
            'ORD': { label: 'ORD (AO, Rough, Disp)', ch: { R:'AO', G:'ROUGH', B:'DISP', A:'EMPTY' } },
            'ORM': { label: 'ORM (AO, Rough, Metal)', ch: { R:'AO', G:'ROUGH', B:'METAL', A:'EMPTY' } },
            'RMA': { label: 'RMA (Rough, Metal, AO)', ch: { R:'ROUGH', G:'METAL', B:'AO', A:'EMPTY' } },
            'UNITY': { label: 'Unity HDRP', ch: { R:'METAL', G:'AO', B:'DISP', A:'SMOOTH' } }
        };
        const NAMES = { AO:'Ambient Occlusion', ROUGH:'Roughness', METAL:'Metallic', DISP:'Displacement', SMOOTH:'Smoothness', EMPTY:'Empty' };

        // --- STATE ---
        let state = {
            mode: 'create',
            srcImg: null, // Image object
            srcOriginalData: null, // Uint8ClampedArray of Source
            w: 0, h: 0,
            maps: { AO:null, ROUGH:null, METAL:null, DISP:null, SMOOTH:null }, // For Create/Convert
            rawChannels: { R:null, G:null, B:null, A:null }, // For Channels Mode
            editData: null // For Editor Mode
        };

        // --- DOM ---
        const el = (id) => document.getElementById(id);

        // --- INIT ---
        function init() {
            Object.keys(FORMATS).forEach(k => {
                el('sourceFormat').add(new Option(FORMATS[k].label, k));
                el('targetFormat').add(new Option(FORMATS[k].label, k));
            });
            el('targetFormat').value = 'ORD';

            // Inputs
            el('sourceInput').onchange = (e) => loadSource(e.target.files[0]);
            el('processBtn').onclick = process;
            el('targetFormat').onchange = updateUI;
            el('sourceFormat').onchange = () => { if(state.srcImg) unpack(); };
            
            // Sliders (Editor)
            ['b','c','s','h','sh','th'].forEach(k => el('sl-'+k).oninput = updateEditorPreview);

            setMode('create');
        }

        // --- CORE UI ---
        function toggleTheme() {
            const h = document.documentElement;
            h.setAttribute('data-theme', h.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        }

        function setMode(mode) {
            state.mode = mode;
            // Update UI Colors
            document.documentElement.style.setProperty('--accent', `var(${MODES[mode].col})`);
            
            // Update Tabs
            document.querySelectorAll('.nav-tab').forEach(b => {
                b.classList.toggle('active', b.innerText === MODES[mode].name);
            });
            
            // Update Headers
            el('modeBadge').innerText = MODES[mode].badge;
            el('modeBadge').style.color = `var(${MODES[mode].col})`;
            el('modeBadge').style.borderColor = `var(${MODES[mode].col})`;

            // Reset State
            resetState();
            
            // Visibility Logic
            const showSrc = ['convert', 'separate', 'editor'].includes(mode) || (mode === 'channels' && el('channelOp').value === 'split');
            const showTgt = ['create', 'convert'].includes(mode);
            const showSlots = ['create', 'convert', 'separate', 'channels'].includes(mode);
            const showEditor = mode === 'editor';
            const showChConfig = mode === 'channels';

            el('sourceConfig').classList.toggle('d-none', !showSrc);
            el('srcFormatGroup').style.display = (mode === 'convert' || mode === 'separate') ? 'block' : 'none';
            el('targetConfig').classList.toggle('d-none', !showTgt);
            el('slotsSection').classList.toggle('d-none', !showSlots);
            el('editorControls').style.display = showEditor ? 'block' : 'none';
            el('channelsConfig').classList.toggle('d-none', !showChConfig);
            
            el('processBtn').innerText = getBtnText();
            el('processBtn').disabled = true;
            
            updateUI();
        }

        function getBtnText() {
            if(state.mode === 'separate' || (state.mode === 'channels' && el('channelOp').value === 'split')) return "Extract All";
            if(state.mode === 'editor') return "Export Edited Image";
            return "Generate Texture";
        }

        function resetState() {
            state.srcImg = null; state.srcOriginalData = null;
            state.maps = { AO:null, ROUGH:null, METAL:null, DISP:null, SMOOTH:null };
            state.rawChannels = { R:null, G:null, B:null, A:null };
            state.editData = null;
            el('sourceSlot').classList.remove('filled'); el('sourceSlot').classList.add('missing');
            el('sourceName').innerText = "Select Image";
            el('previewContainer').innerHTML = '<div class="empty-state"><div class="empty-icon">ðŸ–¼</div><div>Preview Output</div></div>';
            el('resultsGrid').innerHTML = ''; el('resultsGrid').style.display = 'none';
        }

        // --- UPDATE UI SLOTS ---
        function updateUI() {
            const area = el('slotsArea'); area.innerHTML = '';
            
            if(state.mode === 'create' || state.mode === 'convert') {
                const fmt = FORMATS[el('targetFormat').value];
                ['R','G','B','A'].forEach(c => {
                    const type = fmt.ch[c]; if(type==='EMPTY') return;
                    // Auto-derive
                    let has = !!state.maps[type];
                    if(!has && type==='SMOOTH' && state.maps['ROUGH']) has = true;
                    if(!has && type==='ROUGH' && state.maps['SMOOTH']) has = true;
                    
                    createSlot(c, NAMES[type], has, state.mode==='create', (f) => loadMap(type, f));
                });
                // Check ready
                const req = ['R','G','B','A'].map(c => fmt.ch[c]).filter(t => t!=='EMPTY');
                const ready = req.every(t => state.maps[t] || (t==='SMOOTH' && state.maps['ROUGH']) || (t==='ROUGH' && state.maps['SMOOTH']));
                el('processBtn').disabled = !ready;
            } 
            else if (state.mode === 'separate') {
                if(!state.srcImg) return;
                const fmt = FORMATS[el('sourceFormat').value];
                ['R','G','B','A'].forEach(c => {
                    createSlot(c, NAMES[fmt.ch[c]] + ` (${c})`, true, false, null);
                });
                el('processBtn').disabled = false;
            }
            else if (state.mode === 'channels') {
                const op = el('channelOp').value;
                el('sourceConfig').classList.toggle('d-none', op !== 'split');
                if(op === 'merge') {
                    ['R','G','B','A'].forEach(c => {
                        createSlot(c, `Channel ${c}`, !!state.rawChannels[c], true, (f) => loadRawChannel(c, f));
                    });
                    el('processBtn').disabled = !(state.rawChannels.R || state.rawChannels.G || state.rawChannels.B);
                } else {
                    // Split
                    if(state.srcImg) {
                        ['R','G','B','A'].forEach(c => createSlot(c, `Channel ${c}`, true, false, null));
                        el('processBtn').disabled = false;
                    }
                }
            }
            else if (state.mode === 'editor') {
                el('processBtn').disabled = !state.srcImg;
            }
        }

        function createSlot(badge, name, filled, allowUpload, cb) {
            const div = document.createElement('div');
            div.className = `slot ${filled ? 'filled' : 'missing'}`;
            div.innerHTML = `
                <div class="ch-badge bg-${badge.charAt(0)}">${badge}</div>
                <div class="slot-info">
                    <div class="slot-name">${name}</div>
                    <div class="slot-meta">${filled ? 'Ready' : 'Drag & Drop or Click'}</div>
                </div>
                ${!filled ? `<div class="import-visual">Upload <span>+</span></div>` : ''}
            `;
            
            if(allowUpload) {
                const inp = document.createElement('input');
                inp.type = 'file'; inp.accept = 'image/*'; inp.className = 'file-input';
                inp.onchange = (e) => cb(e.target.files[0]);
                div.appendChild(inp);
            }
            el('slotsArea').appendChild(div);
        }

        // --- LOGIC ---
        function loadSource(file) {
            if(!file) return;
            el('sourceName').innerText = file.name;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    state.w = img.width; state.h = img.height; state.srcImg = img;
                    el('dimInfo').innerText = `${state.w} Ã— ${state.h}`;
                    el('sourceSlot').classList.remove('missing'); el('sourceSlot').classList.add('filled');
                    
                    // Canvas data extraction
                    const c = document.createElement('canvas'); c.width = state.w; c.height = state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0);
                    state.srcOriginalData = ctx.getImageData(0,0,state.w,state.h);
                    
                    if(state.mode !== 'editor') unpack(); 
                    else updateEditorPreview();
                    
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function loadMap(type, file) {
            if(!file) return;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    if(state.w===0) { state.w=img.width; state.h=img.height; el('dimInfo').innerText=`${state.w}Ã—${state.h}`;}
                    const c = document.createElement('canvas'); c.width=state.w; c.height=state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,state.w,state.h);
                    state.maps[type] = extract(ctx.getImageData(0,0,state.w,state.h), 0);
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function loadRawChannel(ch, file) {
            if(!file) return;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    if(state.w===0) { state.w=img.width; state.h=img.height; el('dimInfo').innerText=`${state.w}Ã—${state.h}`;}
                    const c = document.createElement('canvas'); c.width=state.w; c.height=state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,state.w,state.h);
                    state.rawChannels[ch] = extract(ctx.getImageData(0,0,state.w,state.h), 0);
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function unpack() {
            if(!state.srcOriginalData) return;
            const d = state.srcOriginalData;
            
            if(state.mode === 'channels') {
                // Raw Split
                state.rawChannels.R = extract(d, 0);
                state.rawChannels.G = extract(d, 1);
                state.rawChannels.B = extract(d, 2);
                state.rawChannels.A = extract(d, 3);
            } else {
                // Preset Split
                const fmt = FORMATS[el('sourceFormat').value];
                const idx = {R:0, G:1, B:2, A:3};
                state.maps = {AO:null,ROUGH:null,METAL:null,DISP:null,SMOOTH:null};
                ['R','G','B','A'].forEach(ch => {
                    const t = fmt.ch[ch]; if(t!=='EMPTY') state.maps[t] = extract(d, idx[ch]);
                });
            }
            updateUI();
        }

        function extract(idata, off) {
            const len = idata.data.length/4; const res = new Uint8ClampedArray(len);
            for(let i=0;i<len;i++) res[i] = idata.data[i*4+off];
            return res;
        }

        // --- EDITOR LOGIC ---
        let editCanvas = document.createElement('canvas'); // Offscreen processing
        
        function updateEditorPreview() {
            if(!state.srcOriginalData) return;
            // Debounce or lightweight preview could go here, but we'll do direct draw for simplicity
            // To be efficient, we do the processing on a small canvas for preview if image is huge
            applyRealtimeEdit();
        }

        function applyRealtimeEdit() {
            if(!state.srcOriginalData) return;
            const w = state.w; const h = state.h;
            
            // 1. Put Original Data
            editCanvas.width = w; editCanvas.height = h;
            const ctx = editCanvas.getContext('2d');
            ctx.putImageData(state.srcOriginalData, 0, 0);
            
            // 2. CSS Filters
            const b = el('sl-b').value, c = el('sl-c').value, s = el('sl-s').value, hue = el('sl-h').value;
            
            // We use a temp canvas to draw the filtered image
            const temp = document.createElement('canvas'); temp.width=w; temp.height=h;
            const tCtx = temp.getContext('2d');
            tCtx.filter = `brightness(${b}%) contrast(${c}%) hue-rotate(${hue}deg) saturate(${s}%)`;
            tCtx.drawImage(editCanvas, 0, 0);
            
            // 3. Pixel Manipulation (Sharpness/Threshold)
            let final = tCtx.getImageData(0,0,w,h);
            const sh = parseInt(el('sl-sh').value);
            if(sh > 0) final = applySharpen(final, sh);
            
            const th = parseInt(el('sl-th').value);
            if(th > 0) applyThreshold(final, th);

            // Display
            el('previewContainer').innerHTML = '';
            const displayCvs = document.createElement('canvas');
            displayCvs.width = w; displayCvs.height = h;
            displayCvs.getContext('2d').putImageData(final, 0, 0);
            el('previewContainer').appendChild(displayCvs);
            
            // Save for export
            state.editData = final;
            el('processBtn').disabled = false;
        }

        function applyThreshold(idata, th) {
            const d = idata.data;
            for(let i=0; i<d.length; i+=4) {
                const avg = (d[i]+d[i+1]+d[i+2])/3;
                const v = avg >= th ? 255 : 0;
                d[i]=d[i+1]=d[i+2]=v;
            }
        }

        function applySharpen(idata, amt) {
            const w=idata.width, h=idata.height, s=idata.data;
            const res = new Uint8ClampedArray(s.length);
            const m = amt*0.2;
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const i = (y*w+x)*4;
                    // Simple kernel convolution
                    const c=s[i], n=s[((y>0?y-1:y)*w+x)*4], so=s[((y<h-1?y+1:y)*w+x)*4], e=s[(y*w+(x<w-1?x+1:x))*4], we=s[(y*w+(x>0?x-1:x))*4];
                    const val = c + (4*c - n - so - e - we) * m;
                    res[i]=val; res[i+1]=val; res[i+2]=val; res[i+3]=s[i+3];
                }
            }
            return new ImageData(res, w, h);
        }

        // --- PROCESS ---
        function process() {
            if(state.mode === 'editor') {
                if(state.editData) download(state.editData, `Edited_Texture.${el('exportType').value}`);
                return;
            }

            el('previewContainer').innerHTML = '';
            el('resultsGrid').innerHTML = ''; el('resultsGrid').style.display='none';

            if(state.mode === 'separate' || (state.mode === 'channels' && el('channelOp').value === 'split')) {
                // Split Logic
                el('resultsGrid').style.display='grid';
                el('previewContainer').style.display='none';
                
                const labels = state.mode === 'channels' ? {R:'Red',G:'Green',B:'Blue',A:'Alpha'} : 
                               {R:'R',G:'G',B:'B',A:'A'}; // Simplification
                               
                const dataSrc = state.mode === 'channels' ? state.rawChannels : state.maps;
                
                // If Separate Mode, map back using Format
                if(state.mode === 'separate') {
                    const fmt = FORMATS[el('sourceFormat').value];
                    ['R','G','B','A'].forEach(c => {
                        const t = fmt.ch[c]; if(t!=='EMPTY') createCard(state.maps[t], NAMES[t]);
                    });
                } else {
                    // Channels Split
                    ['R','G','B','A'].forEach(c => createCard(state.rawChannels[c], `Channel ${c}`));
                }
                
                function createCard(data, title) {
                    if(!data) return;
                    const cvs = document.createElement('canvas'); cvs.width=state.w; cvs.height=state.h;
                    const id = new ImageData(state.w, state.h);
                    for(let i=0;i<data.length;i++) { id.data[i*4]=data[i]; id.data[i*4+1]=data[i]; id.data[i*4+2]=data[i]; id.data[i*4+3]=255; }
                    cvs.getContext('2d').putImageData(id,0,0);
                    
                    const card = document.createElement('div'); card.className='result-card';
                    card.innerHTML = `<div class="result-thumb"></div><div style="font-size:0.8rem;text-align:center;">${title}</div>`;
                    card.querySelector('.result-thumb').appendChild(cvs);
                    const btn = document.createElement('a'); btn.className='dl-btn'; btn.innerText='Download';
                    btn.onclick = () => download(id, `${title}.${el('exportType').value}`);
                    card.appendChild(btn);
                    el('resultsGrid').appendChild(card);
                }
            } else {
                // Merge Logic (Create / Convert / Channels Merge)
                el('previewContainer').style.display='flex';
                
                const final = new Uint8ClampedArray(state.w*state.h*4);
                let r,g,b,a;
                
                if(state.mode === 'channels') {
                    r=state.rawChannels.R; g=state.rawChannels.G; b=state.rawChannels.B; a=state.rawChannels.A;
                } else {
                    const fmt = FORMATS[el('targetFormat').value];
                    const getD = (t) => {
                        if(t==='EMPTY') return null;
                        if(state.maps[t]) return state.maps[t];
                        if(t==='SMOOTH' && state.maps['ROUGH']) return state.maps['ROUGH'].map(v=>255-v);
                        if(t==='ROUGH' && state.maps['SMOOTH']) return state.maps['SMOOTH'].map(v=>255-v);
                        return null;
                    };
                    r=getD(fmt.ch.R); g=getD(fmt.ch.G); b=getD(fmt.ch.B); a=getD(fmt.ch.A);
                }

                for(let i=0; i<state.w*state.h; i++) {
                    final[i*4] = r?r[i]:0; final[i*4+1] = g?g[i]:0; 
                    final[i*4+2] = b?b[i]:0; final[i*4+3] = a?a[i]:255;
                }
                
                const id = new ImageData(final, state.w, state.h);
                const cvs = document.createElement('canvas'); cvs.width=state.w; cvs.height=state.h;
                cvs.getContext('2d').putImageData(id,0,0);
                el('previewContainer').appendChild(cvs);
                
                const btn = document.createElement('a'); btn.className='dl-btn'; 
                btn.style.width='200px'; btn.innerText='Download Merged';
                btn.onclick = () => download(id, `Texture_Packed.${el('exportType').value}`);
                el('previewContainer').appendChild(btn);
            }
        }

        function download(idata, name) {
            const cvs = document.createElement('canvas'); cvs.width=state.w; cvs.height=state.h;
            cvs.getContext('2d').putImageData(idata,0,0);
            const ext = el('exportType').value;
            let mime = 'image/png';
            if(ext === 'jpg') mime = 'image/jpeg';
            if(ext === 'webp') mime = 'image/webp';
            
            const l = document.createElement('a'); l.download = name;
            l.href = cvs.toDataURL(mime, 0.9); l.click();
        }

        init();
    </script>
</body>
</html>
