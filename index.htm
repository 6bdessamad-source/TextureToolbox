<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture Toolbox Pro V11</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            /* --- BASICS --- */
            --bg-body: #050505;
            --bg-card: #121212;
            --bg-input: #1a1a1a;
            --bg-hover: #252525;
            --bg-elevated: #1e1e1e;
            
            --border: #2a2a2a;
            --border-active: #404040;
            
            --text-main: #ffffff;
            --text-sec: #9ca3af;
            --text-dim: #6b7280;
            
            /* --- MODES COLORS --- */
            --col-create: #d17756;   /* Terracotta */
            --col-convert: #c026d3;  /* Magenta */
            --col-separate: #0ea5e9; /* Sky Blue */
            --col-editor: #10b981;   /* Emerald */
            --col-channels: #f59e0b; /* Amber */
            --col-generator: #8b5cf6; /* Violet */

            /* Default Accent */
            --accent: var(--col-create);
            --accent-dim: rgba(209, 119, 86, 0.15);
            
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            
            --shadow: 0 8px 30px rgba(0,0,0,0.5);
            --radius: 12px;
            --font-ui: 'Inter', sans-serif;
            --nav-height: 70px;
            
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        [data-theme="light"] {
            --bg-body: #f8fafc;
            --bg-card: #ffffff;
            --bg-input: #f1f5f9;
            --bg-hover: #e2e8f0;
            --bg-elevated: #ffffff;
            --border: #e2e8f0;
            --border-active: #cbd5e1;
            --text-main: #0f172a;
            --text-sec: #64748b;
            --text-dim: #94a3b8;
            --shadow: 0 10px 30px rgba(0,0,0,0.08);
            --grid-color: rgba(0, 0, 0, 0.03);
        }

        * { box-sizing: border-box; outline: none; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg-body);
            background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: 24px 24px;
            color: var(--text-main);
            font-family: var(--font-ui);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        /* --- HEADER --- */
        .navbar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 0 1.5rem;
            height: var(--nav-height);
            display: flex; align-items: center; justify-content: space-between;
            flex-shrink: 0; z-index: 100;
        }

        .brand {
            display: flex; align-items: center; gap: 12px;
            font-weight: 800; font-size: 1.1rem; letter-spacing: -0.5px;
        }
        .brand-icon {
            width: 36px; height: 36px; background: var(--bg-input);
            border: 1px solid var(--border); border-radius: 8px;
            overflow: hidden; display: flex; align-items: center; justify-content: center;
        }
        .brand-text span { color: var(--accent); transition: color 0.3s; }

        .nav-center {
            display: flex; gap: 4px; background: var(--bg-input);
            padding: 4px; border-radius: 8px; border: 1px solid var(--border);
            overflow-x: auto; max-width: 60vw;
        }
        .nav-tab {
            padding: 6px 16px; border: none; background: transparent;
            color: var(--text-sec); font-weight: 600; cursor: pointer;
            border-radius: 6px; font-size: 0.8rem; white-space: nowrap;
            transition: all 0.2s;
        }
        .nav-tab:hover { color: var(--text-main); background: var(--bg-hover); }
        .nav-tab.active { background: var(--bg-card); color: var(--accent); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        .nav-right { display: flex; gap: 10px; }
        .icon-btn {
            width: 36px; height: 36px; border-radius: 8px;
            background: var(--bg-input); border: 1px solid var(--border);
            color: var(--text-sec); cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.1rem; transition: all 0.2s;
        }
        .icon-btn:hover { border-color: var(--accent); color: var(--accent); }

        /* --- MAIN LAYOUT --- */
        .main-container {
            display: grid; grid-template-columns: 400px 1fr; gap: 24px;
            padding: 24px; flex: 1; max-width: 1800px; margin: 0 auto;
            width: 100%; overflow: hidden;
        }

        .panel {
            background: var(--bg-card); border: 1px solid var(--border);
            border-radius: var(--radius); display: flex; flex-direction: column;
            overflow: hidden; box-shadow: var(--shadow); position: relative;
        }

        .panel-header {
            padding: 16px 20px; border-bottom: 1px solid var(--border);
            font-weight: 700; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--bg-elevated); color: var(--text-sec);
        }
        .panel-badge {
            font-size: 0.65rem; background: var(--accent-dim); padding: 2px 8px;
            border-radius: 4px; color: var(--accent); border: 1px solid var(--accent);
        }

        .panel-scroll { padding: 20px; overflow-y: auto; flex: 1; }

        /* --- CONTROLS --- */
        .config-group { margin-bottom: 20px; }
        label {
            display: block; font-size: 0.75rem; font-weight: 700;
            color: var(--text-dim); margin-bottom: 8px; text-transform: uppercase;
        }
        select, input[type="number"], input[type="text"] {
            width: 100%; padding: 10px; background: var(--bg-input);
            border: 1px solid var(--border); color: var(--text-main);
            border-radius: 8px; cursor: pointer; font-size: 0.85rem; appearance: none;
            font-family: inherit;
        }
        select:focus, input:focus { border-color: var(--accent); }
        
        .input-row { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
        .grid-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }

        /* --- SLOTS & UPLOADS --- */
        .slots-wrapper { display: flex; flex-direction: column; gap: 10px; }
        .slot {
            position: relative; background: var(--bg-input);
            border: 1px solid var(--border); border-radius: 8px; padding: 10px;
            display: flex; align-items: center; gap: 12px; transition: all 0.2s;
        }
        .slot:hover { border-color: var(--border-active); background: var(--bg-hover); }
        .slot.filled { background: var(--bg-card); border-left: 4px solid var(--success); }
        .slot.missing { border-left: 4px dashed var(--warning); opacity: 0.9; }

        .ch-badge {
            width: 32px; height: 32px; border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            font-weight: 800; font-size: 0.8rem; color: #fff; flex-shrink: 0;
        }
        .bg-R { background: #ef4444; } .bg-G { background: #10b981; }
        .bg-B { background: #3b82f6; } .bg-A { background: #6b7280; }
        .bg-M { background: #c026d3; }

        .slot-info { flex: 1; pointer-events: none; min-width: 0; }
        .slot-name { font-weight: 600; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-main); }
        .slot-meta { font-size: 0.7rem; color: var(--text-dim); display: flex; gap: 6px; align-items: center; }
        
        .file-input { position: absolute; inset: 0; opacity: 0; cursor: pointer; z-index: 1; }
        .import-visual {
            position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
            display: flex; align-items: center; gap: 6px; pointer-events: none;
            color: var(--text-dim); font-size: 0.75rem; font-weight: 600;
        }

        /* --- GENERATOR SPECIFIC --- */
        .gen-palette-item { display: flex; gap: 5px; align-items: center; margin-bottom: 6px; }
        .gen-palette-item input[type="color"] { flex-grow: 1; height: 32px; border: none; padding: 0; background: none; cursor: pointer; border-radius: 4px; }
        .trans-toggle {
            width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;
            border: 1px solid var(--border); border-radius: 6px; cursor: pointer; background: var(--bg-input);
            font-size: 0.7rem; color: var(--text-dim);
        }
        .trans-toggle.active { background: var(--accent); color: white; border-color: var(--accent); }
        
        .btn-sec { background: var(--bg-input); color: var(--text-sec); border: 1px solid var(--border); padding: 8px; border-radius: 6px; cursor: pointer; font-size: 0.8rem; font-weight: 600; transition:0.2s; }
        .btn-sec:hover { border-color: var(--accent); color: var(--text-main); }

        /* --- PREVIEW --- */
        .preview-wrapper {
            flex: 1; display: flex; flex-direction: column; background-color: var(--bg-input);
            background-image: 
                linear-gradient(45deg, var(--border) 25%, transparent 25%), 
                linear-gradient(-45deg, var(--border) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, var(--border) 75%), 
                linear-gradient(-45deg, transparent 75%, var(--border) 75%);
            background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            align-items: center; justify-content: center; padding: 20px; overflow: hidden;
        }
        canvas { max-width: 100%; max-height: 100%; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border-radius: 8px; object-fit: contain; }

        .empty-state { text-align: center; color: var(--text-dim); opacity: 0.5; }
        .empty-icon { font-size: 3rem; margin-bottom: 10px; }

        /* --- EDITOR CONTROLS --- */
        .slider-row { margin-bottom: 12px; }
        .slider-head { display: flex; justify-content: space-between; font-size: 0.75rem; color: var(--text-sec); margin-bottom: 4px; font-weight:600;}
        input[type=range] { width: 100%; -webkit-appearance: none; background: var(--bg-input); height: 4px; border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 0 4px var(--bg-card);
        }
        .mini-btn {
            width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border);
            background: var(--bg-input); color: var(--text-sec); cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        .mini-btn:hover { color: var(--accent); border-color: var(--accent); background: var(--bg-elevated); }

        /* --- RESULTS GRID --- */
        .results-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px; width: 100%; padding: 15px; background: var(--bg-elevated);
            border-top: 1px solid var(--border); max-height: 250px; overflow-y: auto;
        }
        .result-card {
            background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px;
            padding: 8px; display: flex; flex-direction: column; gap: 8px;
        }
        .result-thumb {
            aspect-ratio: 1; background: #000; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .result-thumb canvas { width: 100%; height: 100%; box-shadow: none; border: none; }
        .dl-btn {
            width: 100%; padding: 6px; background: var(--bg-input); border: 1px solid var(--border);
            border-radius: 4px; color: var(--text-main); font-size: 0.7rem; cursor: pointer;
            text-align: center; text-decoration: none; font-weight: 600;
        }
        .dl-btn:hover { background: var(--accent); border-color: var(--accent); color: #fff; }

        /* --- ACTION AREA --- */
        .action-area { padding: 20px; background: var(--bg-elevated); border-top: 1px solid var(--border); }
        .btn-large {
            width: 100%; padding: 14px; border: none; border-radius: 10px;
            background: var(--accent); color: #fff; font-weight: 700; font-size: 0.95rem;
            cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.2); transition: all 0.2s;
        }
        .btn-large:hover:not(:disabled) { filter: brightness(1.1); transform: translateY(-1px); }
        .btn-large:disabled { opacity: 0.5; cursor: not-allowed; background: var(--bg-input); color: var(--text-sec); box-shadow: none; transform: none; }

        .d-none { display: none !important; }

        @media (max-width: 900px) {
            .main-container { grid-template-columns: 1fr; padding: 10px; height: auto; overflow: visible;}
            .panel { height: auto; min-height: 400px; }
            .nav-center { overflow-x: scroll; }
        }
    </style>
</head>
<body>

    <nav class="navbar">
        <div class="brand">
            <div class="brand-icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                    <path d="M4 8h16"></path>
                    <path d="M8 8v12"></path>
                </svg>
            </div>
            <div class="brand-text">Texture<span>Toolbox</span></div>
        </div>
        
        <div class="nav-center">
            <button class="nav-tab active" onclick="setMode('create')">Create</button>
            <button class="nav-tab" onclick="setMode('convert')">Convert</button>
            <button class="nav-tab" onclick="setMode('separate')">Separate</button>
            <button class="nav-tab" onclick="setMode('generator')">Generator</button>
            <button class="nav-tab" onclick="setMode('editor')">Editor</button>
            <button class="nav-tab" onclick="setMode('channels')">Channels</button>
        </div>

        <div class="nav-right">
            <button class="icon-btn" onclick="toggleTheme()">â˜€</button>
        </div>
    </nav>

    <div class="main-container">
        
        <div class="panel">
            <div class="panel-header">
                <span id="panelTitle">Configuration</span>
                <span class="panel-badge" id="modeBadge">CREATE</span>
            </div>
            <div class="panel-scroll">
                
                <div id="sourceConfig" class="d-none config-group">
                    <label>Source File</label>
                    <div class="slot missing" id="sourceSlot">
                        <div class="ch-badge bg-M">SRC</div>
                        <div class="slot-info">
                            <div class="slot-name" id="sourceName">Select Image</div>
                            <div class="slot-meta">Drag & Drop or Click</div>
                        </div>
                        <input type="file" class="file-input" id="sourceInput" accept="image/*">
                    </div>
                    <div id="srcFormatGroup" style="margin-top:12px;">
                        <label>Source Format</label>
                        <select id="sourceFormat"></select>
                    </div>
                </div>

                <div id="genConfig" class="d-none config-group">
                    <label>Dimensions</label>
                    <div class="input-row">
                        <input type="number" id="genW" value="1024">
                        <span style="font-size:0.7rem">x</span>
                        <input type="number" id="genH" value="1024">
                    </div>
                    <div class="grid-row">
                        <button class="btn-sec" onclick="setGenRes(512)">512</button>
                        <button class="btn-sec" onclick="setGenRes(1024)">1024</button>
                        <button class="btn-sec" onclick="setGenRes(2048)">2k</button>
                    </div>

                    <label style="margin-top:16px;">Pattern</label>
                    <select id="genType">
                        <option value="checker">Checkerboard</option>
                        <option value="brick">Brick (Running Bond)</option>
                        <option value="herring">Herringbone</option>
                        <option value="basket">Basketweave</option>
                        <option value="grid">Grid / Tiles</option>
                        <option value="hex">Hexagonal</option>
                        <option value="stripes">Linear Stripes</option>
                        <option value="dots">Polka Dots</option>
                        <option value="noise">Noise / Grain</option>
                    </select>

                    <div style="margin-top:16px;">
                        <div class="slider-row" id="grp-scale">
                            <div class="slider-head"><span id="lbl-scale">Scale</span><span id="val-scale">100</span></div>
                            <input type="range" id="rng-scale" min="1" max="500" value="100">
                        </div>
                        <div class="slider-row" id="grp-aspect">
                            <div class="slider-head"><span>Aspect Ratio</span><span id="val-aspect">2.0</span></div>
                            <input type="range" id="rng-aspect" min="0.2" max="5.0" step="0.1" value="2.0">
                        </div>
                        <div class="slider-row" id="grp-space">
                            <div class="slider-head"><span>Grout / Spacing</span><span id="val-space">4</span></div>
                            <input type="range" id="rng-space" min="0" max="50" value="4">
                        </div>
                        <div class="slider-row" id="grp-rot">
                            <div class="slider-head"><span>Rotation</span><span id="val-rot">0Â°</span></div>
                            <input type="range" id="rng-rot" min="0" max="180" value="0">
                        </div>
                        <div class="slider-row">
                            <div class="slider-head"><span id="lbl-rough">Roughness</span><span id="val-rough">0</span></div>
                            <input type="range" id="rng-rough" min="0" max="100" value="0">
                        </div>
                    </div>

                    <div style="border-top:1px solid var(--border); padding-top:16px; margin-top:16px;">
                        <div class="input-row" style="justify-content: space-between;">
                            <label>Palette</label>
                            <div class="input-row" style="gap:4px;">
                                <span style="font-size:0.7rem; color:var(--text-sec)">Grout:</span>
                                <input type="color" id="genGrout" value="#111111" style="width:30px; height:24px; padding:0; border:none; border-radius:4px;">
                            </div>
                        </div>
                        <div class="input-row">
                            <input type="number" id="genNumC" value="3" min="1" max="8" style="width: 50px;">
                            <button class="btn-sec" id="genRandBtn" style="flex:1">Random</button>
                            <button class="btn-sec" id="genGrayBtn" style="flex:1">B&W</button>
                        </div>
                        <div id="genColorList" style="margin-top: 8px;"></div>
                        <div style="margin-top:10px;">
                             <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-weight:500;">
                                <input type="checkbox" id="genLabels"> Enumerate / Label
                            </label>
                        </div>
                    </div>
                </div>

                <div id="channelsConfig" class="d-none config-group">
                    <label>Operation</label>
                    <select id="channelOp" onchange="updateUI()">
                        <option value="merge">Merge Channels (Builder)</option>
                        <option value="split">Split Channels (Extractor)</option>
                    </select>
                </div>

                <div id="targetConfig" class="config-group">
                    <label>Output Preset</label>
                    <select id="targetFormat"></select>
                </div>

                <div id="editorControls" class="d-none">
                    <div class="slider-row"><div class="slider-head"><span>Brightness</span><span id="v-b">100%</span></div><input type="range" id="sl-b" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Contrast</span><span id="v-c">100%</span></div><input type="range" id="sl-c" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Saturation</span><span id="v-s">100%</span></div><input type="range" id="sl-s" min="0" max="200" value="100"></div>
                    <div class="slider-row"><div class="slider-head"><span>Hue</span><span id="v-h">0Â°</span></div><input type="range" id="sl-h" min="-180" max="180" value="0"></div>
                    <div class="slider-row"><div class="slider-head"><span>Sharpness</span><span id="v-sh">0</span></div><input type="range" id="sl-sh" min="0" max="10" step="1" value="0"></div>
                    <div class="slider-row"><div class="slider-head"><span>Threshold</span><span id="v-th">0</span></div><input type="range" id="sl-th" min="0" max="255" value="0"></div>
                    <button class="mini-btn" style="width:100%; margin-top:10px;" onclick="applyRealtimeEdit()">Apply & Render</button>
                </div>

                <div id="slotsSection" style="margin-top:20px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                        <label id="slotTitle">Channels</label>
                    </div>
                    <div class="slots-wrapper" id="slotsArea"></div>
                </div>

            </div>
            
            <div class="action-area">
                <div class="config-group" style="margin-bottom:10px;">
                    <label>Export Format</label>
                    <select id="exportType" style="padding:8px;">
                        <option value="png">PNG (Raster)</option>
                        <option value="jpg">JPG (Compact)</option>
                        <option value="webp">WebP (Modern)</option>
                        <option value="svg" id="optSVG">SVG (Vector - Gen Only)</option>
                    </select>
                    <div id="svgWarning" class="d-none" style="color:var(--warning); font-size:0.7rem; margin-top:5px;">
                         * Noise/Effects render as PNG in SVG mode.
                    </div>
                </div>
                <button id="processBtn" class="btn-large" disabled>Process</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <span>Viewport</span>
                <span id="dimInfo" style="color:var(--text-dim); font-weight:400;">0 Ã— 0</span>
            </div>
            
            <div class="preview-wrapper" id="previewContainer">
                <div class="empty-state">
                    <div class="empty-icon">ðŸ–¼</div>
                    <div>Preview Output</div>
                </div>
            </div>
            
            <div id="resultsGrid" class="results-grid" style="display:none;"></div>
        </div>

    </div>

    <script>
        // --- CONFIG ---
        const MODES = {
            create: { col: '--col-create', name: 'Create', badge: 'PACKER' },
            convert: { col: '--col-convert', name: 'Convert', badge: 'UNPACKER' },
            separate: { col: '--col-separate', name: 'Separate', badge: 'SPLITTER' },
            generator: { col: '--col-generator', name: 'Generator', badge: 'FORGE' },
            editor: { col: '--col-editor', name: 'Editor', badge: 'STUDIO' },
            channels: { col: '--col-channels', name: 'Channels', badge: 'MIXER' }
        };

        const FORMATS = {
            'ORD': { label: 'ORD (AO, Rough, Disp)', ch: { R:'AO', G:'ROUGH', B:'DISP', A:'EMPTY' } },
            'ORM': { label: 'ORM (AO, Rough, Metal)', ch: { R:'AO', G:'ROUGH', B:'METAL', A:'EMPTY' } },
            'RMA': { label: 'RMA (Rough, Metal, AO)', ch: { R:'ROUGH', G:'METAL', B:'AO', A:'EMPTY' } },
            'UNITY': { label: 'Unity HDRP', ch: { R:'METAL', G:'AO', B:'DISP', A:'SMOOTH' } }
        };
        const NAMES = { AO:'Ambient Occlusion', ROUGH:'Roughness', METAL:'Metallic', DISP:'Displacement', SMOOTH:'Smoothness', EMPTY:'Empty' };

        // --- STATE ---
        let state = {
            mode: 'create',
            srcImg: null, srcOriginalData: null,
            w: 0, h: 0,
            maps: { AO:null, ROUGH:null, METAL:null, DISP:null, SMOOTH:null },
            rawChannels: { R:null, G:null, B:null, A:null },
            editData: null,
            // Generator State
            genColors: [{hex: '#8d5524', trans: false}, {hex: '#c68642', trans: false}, {hex: '#e0ac69', trans: false}],
            genRandoms: new Float32Array(4000).map(() => Math.random()),
            genFrameId: null
        };

        const el = (id) => document.getElementById(id);
        const genCanvas = document.createElement('canvas'); // Dedicated generator canvas

        // --- INIT ---
        function init() {
            Object.keys(FORMATS).forEach(k => {
                el('sourceFormat').add(new Option(FORMATS[k].label, k));
                el('targetFormat').add(new Option(FORMATS[k].label, k));
            });
            el('targetFormat').value = 'ORD';

            // General Events
            el('sourceInput').onchange = (e) => loadSource(e.target.files[0]);
            el('processBtn').onclick = process;
            el('targetFormat').onchange = updateUI;
            el('sourceFormat').onchange = () => { if(state.srcImg) unpack(); };
            el('exportType').onchange = () => { 
                if(state.mode === 'generator' && el('exportType').value === 'svg' && el('genType').value === 'noise') 
                    el('svgWarning').classList.remove('d-none');
                else el('svgWarning').classList.add('d-none');
            };

            // Editor Events
            ['b','c','s','h','sh','th'].forEach(k => el('sl-'+k).oninput = updateEditorPreview);

            // Generator Events
            initGeneratorControls();

            setMode('create');
        }

        // --- CORE UI ---
        function toggleTheme() {
            const h = document.documentElement;
            h.setAttribute('data-theme', h.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        }

        function setMode(mode) {
            state.mode = mode;
            document.documentElement.style.setProperty('--accent', `var(${MODES[mode].col})`);
            
            document.querySelectorAll('.nav-tab').forEach(b => {
                b.classList.toggle('active', b.innerText === MODES[mode].name);
            });
            
            el('modeBadge').innerText = MODES[mode].badge;
            el('modeBadge').style.color = `var(${MODES[mode].col})`;
            el('modeBadge').style.borderColor = `var(${MODES[mode].col})`;

            resetState();
            
            const isGen = mode === 'generator';
            const showSrc = ['convert', 'separate', 'editor'].includes(mode) || (mode === 'channels' && el('channelOp').value === 'split');
            const showTgt = ['create', 'convert'].includes(mode);
            const showSlots = ['create', 'convert', 'separate', 'channels'].includes(mode);
            const showEditor = mode === 'editor';
            const showChConfig = mode === 'channels';

            el('sourceConfig').classList.toggle('d-none', !showSrc);
            el('genConfig').classList.toggle('d-none', !isGen);
            el('srcFormatGroup').style.display = (mode === 'convert' || mode === 'separate') ? 'block' : 'none';
            el('targetConfig').classList.toggle('d-none', !showTgt);
            el('slotsSection').classList.toggle('d-none', !showSlots);
            el('editorControls').classList.toggle('d-none', !showEditor);
            el('channelsConfig').classList.toggle('d-none', !showChConfig);
            el('optSVG').disabled = !isGen;
            if(!isGen && el('exportType').value === 'svg') el('exportType').value = 'png';

            el('processBtn').innerText = getBtnText();
            el('processBtn').disabled = true;

            if(isGen) {
                reqDraw();
                el('processBtn').disabled = false;
                el('previewContainer').innerHTML = '';
                el('previewContainer').appendChild(genCanvas);
                el('dimInfo').innerText = `${el('genW').value} Ã— ${el('genH').value}`;
            }

            updateUI();
        }

        function getBtnText() {
            if(state.mode === 'generator') return "Download Texture";
            if(state.mode === 'separate' || (state.mode === 'channels' && el('channelOp').value === 'split')) return "Extract All";
            if(state.mode === 'editor') return "Export Edited Image";
            return "Generate Texture";
        }

        function resetState() {
            state.srcImg = null; state.srcOriginalData = null;
            state.maps = { AO:null, ROUGH:null, METAL:null, DISP:null, SMOOTH:null };
            state.rawChannels = { R:null, G:null, B:null, A:null };
            state.editData = null;
            el('sourceSlot').classList.remove('filled'); el('sourceSlot').classList.add('missing');
            el('sourceName').innerText = "Select Image";
            el('previewContainer').innerHTML = '<div class="empty-state"><div class="empty-icon">ðŸ–¼</div><div>Preview Output</div></div>';
            el('resultsGrid').innerHTML = ''; el('resultsGrid').style.display = 'none';
        }

        function updateUI() {
            const area = el('slotsArea'); area.innerHTML = '';
            
            if(state.mode === 'create' || state.mode === 'convert') {
                const fmt = FORMATS[el('targetFormat').value];
                ['R','G','B','A'].forEach(c => {
                    const type = fmt.ch[c]; if(type==='EMPTY') return;
                    let has = !!state.maps[type];
                    if(!has && type==='SMOOTH' && state.maps['ROUGH']) has = true;
                    if(!has && type==='ROUGH' && state.maps['SMOOTH']) has = true;
                    createSlot(c, NAMES[type], has, state.mode==='create', (f) => loadMap(type, f));
                });
                const req = ['R','G','B','A'].map(c => fmt.ch[c]).filter(t => t!=='EMPTY');
                const ready = req.every(t => state.maps[t] || (t==='SMOOTH' && state.maps['ROUGH']) || (t==='ROUGH' && state.maps['SMOOTH']));
                el('processBtn').disabled = !ready;
            } 
            else if (state.mode === 'separate') {
                if(!state.srcImg) return;
                const fmt = FORMATS[el('sourceFormat').value];
                ['R','G','B','A'].forEach(c => {
                    createSlot(c, NAMES[fmt.ch[c]] + ` (${c})`, true, false, null);
                });
                el('processBtn').disabled = false;
            }
            else if (state.mode === 'channels') {
                const op = el('channelOp').value;
                el('sourceConfig').classList.toggle('d-none', op !== 'split');
                if(op === 'merge') {
                    ['R','G','B','A'].forEach(c => {
                        createSlot(c, `Channel ${c}`, !!state.rawChannels[c], true, (f) => loadRawChannel(c, f));
                    });
                    el('processBtn').disabled = !(state.rawChannels.R || state.rawChannels.G || state.rawChannels.B);
                } else {
                    if(state.srcImg) {
                        ['R','G','B','A'].forEach(c => createSlot(c, `Channel ${c}`, true, false, null));
                        el('processBtn').disabled = false;
                    }
                }
            }
            else if (state.mode === 'editor') {
                el('processBtn').disabled = !state.srcImg;
            }
        }

        function createSlot(badge, name, filled, allowUpload, cb) {
            const div = document.createElement('div');
            div.className = `slot ${filled ? 'filled' : 'missing'}`;
            div.innerHTML = `
                <div class="ch-badge bg-${badge.charAt(0)}">${badge}</div>
                <div class="slot-info">
                    <div class="slot-name">${name}</div>
                    <div class="slot-meta">${filled ? 'Ready' : 'Drag & Drop or Click'}</div>
                </div>
                ${!filled ? `<div class="import-visual">Upload <span>+</span></div>` : ''}
            `;
            if(allowUpload) {
                const inp = document.createElement('input');
                inp.type = 'file'; inp.accept = 'image/*'; inp.className = 'file-input';
                inp.onchange = (e) => cb(e.target.files[0]);
                div.appendChild(inp);
            }
            el('slotsArea').appendChild(div);
        }

        // --- IMAGE LOGIC ---
        function loadSource(file) {
            if(!file) return;
            el('sourceName').innerText = file.name;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    state.w = img.width; state.h = img.height; state.srcImg = img;
                    el('dimInfo').innerText = `${state.w} Ã— ${state.h}`;
                    el('sourceSlot').classList.remove('missing'); el('sourceSlot').classList.add('filled');
                    
                    const c = document.createElement('canvas'); c.width = state.w; c.height = state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0);
                    state.srcOriginalData = ctx.getImageData(0,0,state.w,state.h);
                    
                    if(state.mode !== 'editor') unpack(); 
                    else updateEditorPreview();
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function loadMap(type, file) {
            if(!file) return;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    if(state.w===0) { state.w=img.width; state.h=img.height; el('dimInfo').innerText=`${state.w}Ã—${state.h}`;}
                    const c = document.createElement('canvas'); c.width=state.w; c.height=state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,state.w,state.h);
                    state.maps[type] = extract(ctx.getImageData(0,0,state.w,state.h), 0);
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function loadRawChannel(ch, file) {
            if(!file) return;
            const r = new FileReader();
            r.onload = e => {
                const img = new Image();
                img.onload = () => {
                    if(state.w===0) { state.w=img.width; state.h=img.height; el('dimInfo').innerText=`${state.w}Ã—${state.h}`;}
                    const c = document.createElement('canvas'); c.width=state.w; c.height=state.h;
                    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,state.w,state.h);
                    state.rawChannels[ch] = extract(ctx.getImageData(0,0,state.w,state.h), 0);
                    updateUI();
                };
                img.src = e.target.result;
            };
            r.readAsDataURL(file);
        }

        function unpack() {
            if(!state.srcOriginalData) return;
            const d = state.srcOriginalData;
            if(state.mode === 'channels') {
                state.rawChannels.R = extract(d, 0);
                state.rawChannels.G = extract(d, 1);
                state.rawChannels.B = extract(d, 2);
                state.rawChannels.A = extract(d, 3);
            } else {
                const fmt = FORMATS[el('sourceFormat').value];
                const idx = {R:0, G:1, B:2, A:3};
                state.maps = {AO:null,ROUGH:null,METAL:null,DISP:null,SMOOTH:null};
                ['R','G','B','A'].forEach(ch => {
                    const t = fmt.ch[ch]; if(t!=='EMPTY') state.maps[t] = extract(d, idx[ch]);
                });
            }
            updateUI();
        }

        function extract(idata, off) {
            const len = idata.data.length/4; const res = new Uint8ClampedArray(len);
            for(let i=0;i<len;i++) res[i] = idata.data[i*4+off];
            return res;
        }

        // --- EDITOR LOGIC ---
        let editCanvas = document.createElement('canvas');
        
        function updateEditorPreview() {
            if(!state.srcOriginalData) return;
            applyRealtimeEdit();
        }

        function applyRealtimeEdit() {
            if(!state.srcOriginalData) return;
            const w = state.w; const h = state.h;
            editCanvas.width = w; editCanvas.height = h;
            const ctx = editCanvas.getContext('2d');
            ctx.putImageData(state.srcOriginalData, 0, 0);
            
            const temp = document.createElement('canvas'); temp.width=w; temp.height=h;
            const tCtx = temp.getContext('2d');
            const b = el('sl-b').value, c = el('sl-c').value, s = el('sl-s').value, hue = el('sl-h').value;
            tCtx.filter = `brightness(${b}%) contrast(${c}%) hue-rotate(${hue}deg) saturate(${s}%)`;
            tCtx.drawImage(editCanvas, 0, 0);
            
            let final = tCtx.getImageData(0,0,w,h);
            const sh = parseInt(el('sl-sh').value);
            if(sh > 0) final = applySharpen(final, sh);
            const th = parseInt(el('sl-th').value);
            if(th > 0) applyThreshold(final, th);

            el('previewContainer').innerHTML = '';
            const displayCvs = document.createElement('canvas');
            displayCvs.width = w; displayCvs.height = h;
            displayCvs.getContext('2d').putImageData(final, 0, 0);
            el('previewContainer').appendChild(displayCvs);
            state.editData = final;
            el('processBtn').disabled = false;
        }

        function applyThreshold(idata, th) {
            const d = idata.data;
            for(let i=0; i<d.length; i+=4) {
                const avg = (d[i]+d[i+1]+d[i+2])/3;
                const v = avg >= th ? 255 : 0;
                d[i]=d[i+1]=d[i+2]=v;
            }
        }

        function applySharpen(idata, amt) {
            const w=idata.width, h=idata.height, s=idata.data;
            const res = new Uint8ClampedArray(s.length);
            const m = amt*0.2;
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const i = (y*w+x)*4;
                    const c=s[i], n=s[((y>0?y-1:y)*w+x)*4], so=s[((y<h-1?y+1:y)*w+x)*4], e=s[(y*w+(x<w-1?x+1:x))*4], we=s[(y*w+(x>0?x-1:x))*4];
                    const val = c + (4*c - n - so - e - we) * m;
                    res[i]=val; res[i+1]=val; res[i+2]=val; res[i+3]=s[i+3];
                }
            }
            return new ImageData(res, w, h);
        }

        // --- GENERATOR LOGIC ---
        function initGeneratorControls() {
            const sync = (r, i, l) => { 
                r.oninput = () => { if(l) el(l).innerText = r.value + (l.includes('rot')?'Â°':''); reqDraw(); };
            };
            sync(el('rng-scale'), null, 'val-scale');
            sync(el('rng-aspect'), null, 'val-aspect');
            sync(el('rng-rot'), null, 'val-rot');
            sync(el('rng-space'), null, 'val-space');
            sync(el('rng-rough'), null, 'val-rough');

            ['genW', 'genH', 'genType', 'genGrout', 'genLabels'].forEach(id => el(id).oninput = reqDraw);
            el('genNumC').onchange = genPalette;
            el('genRandBtn').onclick = () => { randCols(false); reqDraw(); };
            el('genGrayBtn').onclick = () => { randCols(true); reqDraw(); };

            genPalette();
        }

        function setGenRes(s) { el('genW').value=s; el('genH').value=s; reqDraw(); }

        function genPalette() {
            let count = parseInt(el('genNumC').value);
            while(state.genColors.length < count) state.genColors.push({hex: randHex(), trans: false});
            
            const list = el('genColorList'); list.innerHTML = '';
            for(let i=0; i<count; i++) {
                const d = document.createElement('div'); d.className = 'gen-palette-item';
                const inp = document.createElement('input'); inp.type='color'; inp.value=state.genColors[i].hex;
                inp.oninput = (e) => { state.genColors[i].hex = e.target.value; reqDraw(); };
                
                const btn = document.createElement('div'); 
                btn.className = `trans-toggle ${state.genColors[i].trans ? 'active' : ''}`;
                btn.innerText = 'Ã˜';
                btn.onclick = () => { 
                    state.genColors[i].trans = !state.genColors[i].trans; 
                    btn.className = state.genColors[i].trans ? 'trans-toggle active' : 'trans-toggle'; 
                    reqDraw(); 
                };
                d.append(inp, btn); list.append(d);
            }
        }

        function randCols(bw) {
            state.genColors.forEach(c => {
                const v = bw ? Math.floor(Math.random()*200+55) : Math.floor(Math.random()*16777215);
                const h = v.toString(16).padStart(6,'0');
                c.hex = bw ? `#${h.substring(0,2).repeat(3)}` : `#${h}`;
            });
            genPalette();
        }
        function randHex() { return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'); }

        function reqDraw() {
            if(state.mode !== 'generator') return;
            const t = el('genType').value;
            const isNoise = t === 'noise';
            el('lbl-scale').innerText = isNoise ? "Grain Size" : "Scale";
            el('lbl-rough').innerText = isNoise ? "Intensity" : "Roughness";
            el('grp-aspect').classList.toggle('d-none', ['dots','noise','hex','checker','stripes'].includes(t));
            el('grp-rot').classList.toggle('d-none', ['noise','checker'].includes(t));
            el('grp-space').classList.toggle('d-none', ['noise','stripes'].includes(t));

            if(state.genFrameId) cancelAnimationFrame(state.genFrameId);
            state.genFrameId = requestAnimationFrame(drawGen);
        }

        function drawGen() {
            const w = parseInt(el('genW').value); const h = parseInt(el('genH').value);
            genCanvas.width = w; genCanvas.height = h;
            el('dimInfo').innerText = `${w} Ã— ${h}`;
            const ctx = genCanvas.getContext('2d');
            const p = {
                t: el('genType').value,
                size: parseInt(el('rng-scale').value),
                asp: parseFloat(el('rng-aspect').value),
                gap: parseInt(el('rng-space').value),
                rot: parseInt(el('rng-rot').value),
                rough: parseInt(el('rng-rough').value),
                lbl: el('genLabels').checked,
                pad: (parseInt(el('rng-rot').value)!==0) ? Math.max(w,h) : 0
            };

            ctx.clearRect(0,0,w,h);
            if(p.t !== 'noise') {
                ctx.fillStyle = el('genGrout').value;
                ctx.fillRect(0,0,w,h);
            }
            ctx.save();
            if(p.rot !== 0 && p.t !== 'noise') {
                ctx.translate(w/2, h/2); ctx.rotate(p.rot * Math.PI / 180); ctx.translate(-w/2, -h/2);
            }
            renderPattern(ctx, w, h, p, false);
            ctx.restore();
        }

        function renderPattern(c, w, h, p, isSVG) {
            const ox = -p.pad, oy = -p.pad;
            const dw = w + p.pad*2, dh = h + p.pad*2;
            const svgOut = [];

            const rect = (x,y,rw,rh,idx, svgAccum) => {
                const cDef = state.genColors[idx % state.genColors.length];
                if(cDef.trans) return;
                const fill = getRoughColor(cDef.hex, p.rough, idx);
                if(isSVG) {
                    svgAccum.push(`<rect x="${x}" y="${y}" width="${rw}" height="${rh}" fill="${fill}" />`);
                    if(p.lbl) svgAccum.push(svgText(x+rw/2, y+rh/2, idx, rw));
                } else {
                    c.fillStyle = fill; c.fillRect(x,y,rw,rh);
                    if(p.lbl) drawLbl(c, x+rw/2, y+rh/2, idx, rw);
                }
            };

            if(p.t === 'noise') {
                if(!isSVG) drawNoise(c, w, h, p.size, p.rough); 
            }
            else if(p.t === 'checker') {
                const cols = Math.ceil(dw/p.size), rows = Math.ceil(dh/p.size);
                for(let y=0; y<rows; y++) for(let x=0; x<cols; x++) 
                    rect(ox+x*p.size, oy+y*p.size, p.size, p.size, (x+y)%2, svgOut);
            }
            else if(p.t === 'grid') {
                const wb = p.size, hb = p.size*p.asp;
                const cols = Math.ceil(dw/wb), rows = Math.ceil(dh/hb);
                for(let y=0; y<rows; y++) for(let x=0; x<cols; x++)
                    rect(ox+x*wb+p.gap/2, oy+y*hb+p.gap/2, wb-p.gap, hb-p.gap, y*cols+x, svgOut);
            }
            else if(p.t === 'brick') {
                const wb = p.size*p.asp, hb = p.size;
                const cols = Math.ceil(dw/wb)+1, rows = Math.ceil(dh/hb);
                for(let y=0; y<rows; y++) {
                    const off = (y%2)*(wb/2);
                    for(let x=-1; x<cols; x++) 
                        rect(ox+x*wb+off+p.gap/2, oy+y*hb+p.gap/2, wb-p.gap, hb-p.gap, y*cols+x, svgOut);
                }
            }
            else if(p.t === 'stripes') {
                const diag = Math.sqrt(w*w + h*h);
                let pos = -diag, idx = 0;
                while(pos < diag) {
                    const cDef = state.genColors[idx % state.genColors.length];
                    if(!cDef.trans) {
                        const fill = getRoughColor(cDef.hex, p.rough, idx);
                        if(isSVG) svgOut.push(`<rect x="${pos}" y="${-diag}" width="${p.size}" height="${diag*2}" fill="${fill}" />`);
                        else { c.fillStyle = fill; c.fillRect(pos, -diag, p.size, diag*2); }
                    }
                    pos += p.size; idx++;
                }
            }
            else if(p.t === 'dots') {
                const grid = p.size + p.gap, rad = p.size/2;
                const cols = Math.ceil(dw/grid), rows = Math.ceil(dh/grid);
                let idx = 0;
                for(let y=0; y<rows; y++) for(let x=0; x<cols; x++) {
                    const cDef = state.genColors[idx % state.genColors.length];
                    if(!cDef.trans) {
                        const cx = ox+x*grid+rad, cy = oy+y*grid+rad;
                        if(isSVG) svgOut.push(`<circle cx="${cx}" cy="${cy}" r="${rad}" fill="${cDef.hex}" />`);
                        else { c.beginPath(); c.arc(cx,cy,rad,0,Math.PI*2); c.fillStyle=cDef.hex; c.fill(); }
                    }
                    idx++;
                }
            }
            return svgOut;
        }

        function drawNoise(c, w, h, scale, intensity) {
            const roughFact = intensity / 100 * 255;
            const cols = Math.ceil(w/scale);
            const rows = Math.ceil(h/scale);
            
            c.fillStyle = state.genColors[0].hex;
            c.fillRect(0,0,w,h);
            if(state.genColors[0].trans) c.clearRect(0,0,w,h);

            for(let y=0; y<rows; y++) {
                for(let x=0; x<cols; x++) {
                    const idx = (y*cols + x);
                    const rand = state.genRandoms[idx % 4000];
                    const noiseVal = (rand - 0.5) * roughFact;
                    if(noiseVal !== 0) {
                        c.fillStyle = noiseVal > 0 ? `rgba(255,255,255,${noiseVal/255})` : `rgba(0,0,0,${Math.abs(noiseVal)/255})`;
                        c.fillRect(x*scale, y*scale, scale, scale);
                    }
                }
            }
        }

        function drawLbl(c, x, y, txt, w) {
            c.fillStyle = '#fff'; c.textAlign='center'; c.textBaseline='middle';
            c.font = `bold ${Math.max(10, w/3)}px Inter`;
            c.fillText(txt, x, y);
            c.strokeStyle = '#000'; c.lineWidth = 2; c.strokeText(txt, x, y);
        }

        function svgText(x, y, txt, w) {
            const fs = Math.max(10, w/3);
            return `<text x="${x}" y="${y}" font-family="Inter, sans-serif" font-weight="bold" font-size="${fs}" text-anchor="middle" dominant-baseline="middle" fill="white" stroke="black" stroke-width="${fs/10}">${txt}</text>`;
        }

        function getRoughColor(hex, rough, idx) {
            if(rough <= 0) return hex;
            const r = parseInt(hex.substr(1,2),16);
            const g = parseInt(hex.substr(3,2),16);
            const b = parseInt(hex.substr(5,2),16);
            const n = (state.genRandoms[idx % 4000] - 0.5) * 100 * (rough/100);
            const clamp = (v) => Math.min(255, Math.max(0, Math.round(v)));
            return `rgb(${clamp(r+n)},${clamp(g+n)},${clamp(b+n)})`;
        }

        // --- EXPORT / PROCESS ---
        function process() {
            const fmt = el('exportType').value;
            
            if(state.mode === 'generator') {
                if(fmt === 'svg' && el('genType').value !== 'noise') {
                    // SVG Export
                    const w = el('genW').value, h = el('genH').value;
                    const p = {
                        t: el('genType').value, size: parseInt(el('rng-scale').value),
                        asp: parseFloat(el('rng-aspect').value), gap: parseInt(el('rng-space').value),
                        rot: parseInt(el('rng-rot').value), rough: parseInt(el('rng-rough').value),
                        lbl: el('genLabels').checked, pad: (parseInt(el('rng-rot').value)!==0) ? Math.max(w,h) : 0
                    };
                    const items = renderPattern(null, parseInt(w), parseInt(h), p, true);
                    let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
                    svgContent += `<rect width="100%" height="100%" fill="${el('genGrout').value}"/>`;
                    const cx = w/2, cy = h/2;
                    if(p.rot !== 0 && p.t !== 'stripes') svgContent += `<g transform="rotate(${p.rot} ${cx} ${cy})">`;
                    else if(p.t === 'stripes' && p.rot !== 0) svgContent += `<g transform="translate(${cx} ${cy}) rotate(${p.rot})">`;
                    else svgContent += `<g>`;
                    svgContent += items.join('');
                    svgContent += `</g></svg>`;
                    const blob = new Blob([svgContent], {type: 'image/svg+xml'});
                    const link = document.createElement('a'); link.href = URL.createObjectURL(blob);
                    link.download = `Pattern_${Date.now()}.svg`; link.click();
                } else {
                    // Raster Export
                    download(genCanvas.getContext('2d').getImageData(0,0,genCanvas.width,genCanvas.height), `Pattern_${Date.now()}.${fmt}`);
                }
                return;
            }

            if(state.mode === 'editor') {
                if(state.editData) download(state.editData, `Edited_Texture.${fmt}`);
                return;
            }

            el('previewContainer').innerHTML = '';
            el('resultsGrid').innerHTML = ''; el('resultsGrid').style.display='none';

            if(state.mode === 'separate' || (state.mode === 'channels' && el('channelOp').value === 'split')) {
                // SPLIT
                el('resultsGrid').style.display='grid';
                el('previewContainer').style.display='none';
                if(state.mode === 'separate') {
                    const sFmt = FORMATS[el('sourceFormat').value];
                    ['R','G','B','A'].forEach(c => {
                        const t = sFmt.ch[c]; if(t!=='EMPTY') createCard(state.maps[t], NAMES[t]);
                    });
                } else {
                    ['R','G','B','A'].forEach(c => createCard(state.rawChannels[c], `Channel ${c}`));
                }
            } else {
                // MERGE
                el('previewContainer').style.display='flex';
                const final = new Uint8ClampedArray(state.w*state.h*4);
                let r,g,b,a;
                if(state.mode === 'channels') {
                    r=state.rawChannels.R; g=state.rawChannels.G; b=state.rawChannels.B; a=state.rawChannels.A;
                } else {
                    const tFmt = FORMATS[el('targetFormat').value];
                    const getD = (t) => {
                        if(t==='EMPTY') return null;
                        if(state.maps[t]) return state.maps[t];
                        if(t==='SMOOTH' && state.maps['ROUGH']) return state.maps['ROUGH'].map(v=>255-v);
                        if(t==='ROUGH' && state.maps['SMOOTH']) return state.maps['SMOOTH'].map(v=>255-v);
                        return null;
                    };
                    r=getD(tFmt.ch.R); g=getD(tFmt.ch.G); b=getD(tFmt.ch.B); a=getD(tFmt.ch.A);
                }

                for(let i=0; i<state.w*state.h; i++) {
                    final[i*4] = r?r[i]:0; final[i*4+1] = g?g[i]:0; 
                    final[i*4+2] = b?b[i]:0; final[i*4+3] = a?a[i]:255;
                }
                
                const id = new ImageData(final, state.w, state.h);
                const cvs = document.createElement('canvas'); cvs.width=state.w; cvs.height=state.h;
                cvs.getContext('2d').putImageData(id,0,0);
                el('previewContainer').appendChild(cvs);
                
                const btn = document.createElement('a'); btn.className='dl-btn'; 
                btn.style.width='200px'; btn.innerText='Download Merged';
                btn.onclick = () => download(id, `Texture_Packed.${fmt}`);
                el('previewContainer').appendChild(btn);
            }
        }

        function createCard(data, title) {
            if(!data) return;
            const cvs = document.createElement('canvas'); cvs.width=state.w; cvs.height=state.h;
            const id = new ImageData(state.w, state.h);
            for(let i=0;i<data.length;i++) { id.data[i*4]=data[i]; id.data[i*4+1]=data[i]; id.data[i*4+2]=data[i]; id.data[i*4+3]=255; }
            cvs.getContext('2d').putImageData(id,0,0);
            
            const card = document.createElement('div'); card.className='result-card';
            card.innerHTML = `<div class="result-thumb"></div><div style="font-size:0.8rem;text-align:center;">${title}</div>`;
            card.querySelector('.result-thumb').appendChild(cvs);
            const btn = document.createElement('a'); btn.className='dl-btn'; btn.innerText='Download';
            btn.onclick = () => download(id, `${title}.${el('exportType').value}`);
            card.appendChild(btn);
            el('resultsGrid').appendChild(card);
        }

        function download(idata, name) {
            const cvs = document.createElement('canvas'); cvs.width=idata.width; cvs.height=idata.height;
            cvs.getContext('2d').putImageData(idata,0,0);
            const ext = el('exportType').value;
            let mime = 'image/png';
            if(ext === 'jpg') mime = 'image/jpeg';
            if(ext === 'webp') mime = 'image/webp';
            
            const l = document.createElement('a'); l.download = name;
            l.href = cvs.toDataURL(mime, 0.9); l.click();
        }

        init();
    </script>
</body>
</html>
